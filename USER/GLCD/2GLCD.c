/****************************************Copyright (c)**************************************************                         
**
**                                 http://www.powermcu.com
**
**--------------File Info-------------------------------------------------------------------------------
** File name:			GLCD.c
** Descriptions:		SSD1963 操作函数库
**						
**------------------------------------------------------------------------------------------------------
** Created by:			AVRman
** Created date:		2011-2-23
** Version:				1.0
** Descriptions:		The original version
**
**------------------------------------------------------------------------------------------------------
** Modified by:			Yu Jingxiong   2011.11.10
** Modified date:		重新阅读并标注加深理解。。。。keep moving！！	
** Version:
** Descriptions:		
********************************************************************************************************/

/* Includes ------------------------------------------------------------------*/
#include "GLCD.h" 
#include "HzLib.h"
#include "AsciiLib.h"
#include "stm32f10x_spi.h"
#include "stm32f10x_fsmc.h"
#include <PictureData.h>
void LCD_FLSAH_DrawPicture(uint16_t StartX,uint16_t StartY,uint16_t EndX,uint16_t EndY, uint8_t * pic);
/* Private define ------------------------------------------------------------*/
/* 使用总线方式时定义地址 */
/* 挂在不同的BANK,使用不同地址线时请自行换算地址 */

//#define LCD_REG              (*((volatile unsigned short *) 0x6C000000)) // RS = 0 
//#define LCD_RAM              (*((volatile unsigned short *) 0x6C000002)) // RS = 1

#define LCD_REG              (*((volatile unsigned short *) 0x6C000000)) /* RS = 0 */
#define LCD_RAM              (*((volatile unsigned short *) 0x6C020000)) /* RS = 1 */

extern void GetGBKCode(unsigned char* pBuffer,unsigned char * c);

/******************************************************************************/
uint8_t	Num_fuhao[224] 	=
{
/*--  文字:  -  --*/
/*--  隶书42;  此字体下对应的点阵为：宽x高=28x56   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=32x56  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xE0,
0x7F,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

};

/*--  文字:  0  --*/
/*--  隶书42; ：宽度x高度=32x56  --*/
uint8_t	Num_0[224] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x3F,0xF0,0x00,0x00,0xFF,0xF8,0x00,0x01,0xFF,0xFE,0x00,\
	0x03,0xFC,0x7F,0x00,0x07,0xF8,0x7F,0x00,0x07,0xF0,0x3F,0x80,0x0F,0xF0,0x3F,0xC0,\
	0x0F,0xE0,0x1F,0xC0,0x1F,0xE0,0x1F,0xC0,0x1F,0xE0,0x1F,0xE0,0x1F,0xC0,0x1F,0xE0,\
	0x1F,0xC0,0x0F,0xE0,0x3F,0xC0,0x0F,0xE0,0x3F,0xC0,0x0F,0xE0,0x3F,0xC0,0x0F,0xF0,\
	0x3F,0xC0,0x0F,0xF0,0x3F,0xC0,0x0F,0xF0,0x3F,0x80,0x0F,0xF0,0x3F,0x80,0x0F,0xF0,\
	0x3F,0x80,0x0F,0xF0,0x3F,0x80,0x0F,0xF0,0x3F,0xC0,0x0F,0xF0,0x3F,0xC0,0x0F,0xF0,\
	0x3F,0xC0,0x0F,0xF0,0x3F,0xC0,0x0F,0xE0,0x3F,0xC0,0x0F,0xE0,0x1F,0xC0,0x0F,0xE0,\
	0x1F,0xC0,0x1F,0xE0,0x1F,0xE0,0x1F,0xE0,0x1F,0xE0,0x1F,0xC0,0x0F,0xE0,0x1F,0xC0,\
	0x0F,0xF0,0x3F,0x80,0x07,0xF0,0x3F,0x80,0x07,0xF8,0x7F,0x00,0x03,0xFC,0xFF,0x00,\
	0x01,0xFF,0xFE,0x00,0x00,0xFF,0xF8,0x00,0x00,0x3F,0xF0,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};																				
/*--  文字:  1  --*/
/*--  隶书42;  ：宽度x高度=32x56  --*/
uint8_t	Num_1[224] 	 =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x03,0xE0,0x00,0x00,0x07,0xE0,0x00,0x00,0x1F,0xE0,0x00,\
	0x03,0xFF,0xE0,0x00,0x03,0xFF,0xE0,0x00,0x00,0x1F,0xE0,0x00,0x00,0x0F,0xE0,0x00,\
	0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,\
	0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,\
	0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,\
	0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,\
	0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,\
	0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,\
	0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x1F,0xE0,0x00,\
	0x00,0x3F,0xF0,0x00,0x03,0xFF,0xFF,0x80,0x03,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

uint8_t	Num_2[224] 	=
{
/*--  文字:  2  --*/
/*--  隶书42;  此字体下对应的点阵为：宽x高=28x56   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=32x56  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xE0,0x00,0x00,0xE0,0xF8,0x00,
0x03,0xC0,0x7C,0x00,0x07,0x80,0x3E,0x00,0x0F,0x00,0x1F,0x00,0x0F,0x00,0x1F,0x00,
0x1F,0x00,0x1F,0x80,0x1F,0x00,0x0F,0x80,0x1F,0x00,0x0F,0x80,0x1F,0x80,0x0F,0x80,
0x1F,0x80,0x0F,0x80,0x1F,0x80,0x1F,0x80,0x0F,0x80,0x1F,0x00,0x00,0x00,0x1F,0x00,
0x00,0x00,0x3E,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0xF8,0x00,
0x00,0x00,0xF0,0x00,0x00,0x01,0xE0,0x00,0x00,0x03,0xC0,0x00,0x00,0x07,0x80,0x00,
0x00,0x0F,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x78,0x00,0x00,
0x00,0xF0,0x00,0x00,0x01,0xE0,0x00,0x00,0x01,0xC0,0x03,0x80,0x03,0xC0,0x03,0x80,
0x07,0x80,0x03,0x80,0x0F,0x00,0x07,0x80,0x1E,0x00,0x07,0x80,0x1C,0x00,0x0F,0x80,
0x3F,0xFF,0xFF,0x00,0x3F,0xFF,0xFF,0x00,0x3F,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

};
/*--  文字:  3  --*/
/*--  隶书42;  宽度x高度=32x56  --*/
uint8_t	Num_3[224] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x7F,0xF0,0x00,0x01,0xFF,0xFC,0x00,0x07,0xF9,0xFE,0x00,\
	0x0F,0xE0,0xFF,0x00,0x0F,0xC0,0x7F,0x00,0x1F,0xC0,0x3F,0x80,0x1F,0xE0,0x3F,0x80,\
	0x1F,0xE0,0x3F,0xC0,0x1F,0xE0,0x3F,0xC0,0x1F,0xE0,0x3F,0xC0,0x0F,0xC0,0x3F,0xC0,\
	0x00,0x00,0x3F,0xC0,0x00,0x00,0x3F,0x80,0x00,0x00,0x7F,0x80,0x00,0x00,0x7F,0x00,\
	0x00,0x00,0xFF,0x00,0x00,0x03,0xFE,0x00,0x00,0x3F,0xF8,0x00,0x00,0x3F,0xFC,0x00,\
	0x00,0x03,0xFE,0x00,0x00,0x00,0x7F,0x80,0x00,0x00,0x3F,0x80,0x00,0x00,0x1F,0xC0,\
	0x00,0x00,0x1F,0xC0,0x00,0x00,0x1F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,\
	0x0F,0xC0,0x0F,0xE0,0x1F,0xE0,0x0F,0xE0,0x1F,0xE0,0x0F,0xE0,0x1F,0xE0,0x1F,0xE0,\
	0x1F,0xE0,0x1F,0xE0,0x1F,0xE0,0x1F,0xC0,0x1F,0xC0,0x3F,0x80,0x0F,0xE0,0x7F,0x80,\
	0x07,0xF9,0xFF,0x00,0x03,0xFF,0xFC,0x00,0x00,0x7F,0xF0,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  4  --*/
/*--  隶书42; ：宽度x高度=32x56  --*/
uint8_t	Num_4[224] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0xFE,0x00,0x00,0x01,0xFE,0x00,\
	0x00,0x01,0xFE,0x00,0x00,0x03,0xFE,0x00,0x00,0x07,0xFE,0x00,0x00,0x07,0xFE,0x00,\
	0x00,0x0F,0xFE,0x00,0x00,0x0F,0xFE,0x00,0x00,0x1F,0xFE,0x00,0x00,0x3F,0xFE,0x00,\
	0x00,0x3F,0xFE,0x00,0x00,0x7E,0xFE,0x00,0x00,0xFC,0xFE,0x00,0x00,0xFC,0xFE,0x00,\
	0x01,0xF8,0xFE,0x00,0x03,0xF0,0xFE,0x00,0x03,0xF0,0xFE,0x00,0x07,0xE0,0xFE,0x00,\
	0x07,0xE0,0xFE,0x00,0x0F,0xC0,0xFE,0x00,0x1F,0x80,0xFE,0x00,0x1F,0x80,0xFE,0x00,\
	0x3F,0x00,0xFE,0x00,0x7E,0x00,0xFE,0x00,0x7F,0xFF,0xFF,0xF0,0x7F,0xFF,0xFF,0xF0,\
	0x00,0x00,0xFE,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0xFE,0x00,\
	0x00,0x00,0xFE,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0xFE,0x00,0x00,0x01,0xFE,0x00,\
	0x00,0x03,0xFF,0x00,0x00,0x3F,0xFF,0xF0,0x00,0x3F,0xFF,0xF0,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  5  --*/
/*--  隶书42; ：宽度x高度=32x56  --*/
uint8_t	Num_5[224] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xC0,0x07,0xFF,0xFF,0xC0,0x07,0xFF,0xFF,0xC0,\
	0x07,0xFF,0xFF,0xC0,0x07,0xC0,0x00,0x00,0x07,0xC0,0x00,0x00,0x07,0xC0,0x00,0x00,\
	0x07,0xC0,0x00,0x00,0x07,0xC0,0x00,0x00,0x07,0xC0,0x00,0x00,0x07,0xC0,0x00,0x00,\
	0x07,0xC0,0x00,0x00,0x0F,0xC0,0x00,0x00,0x0F,0xDF,0xF8,0x00,0x0F,0xFF,0xFE,0x00,\
	0x0F,0xFF,0xFF,0x00,0x0F,0xFC,0xFF,0x80,0x0F,0xF0,0x7F,0xC0,0x0F,0xE0,0x3F,0xC0,\
	0x0F,0xC0,0x1F,0xC0,0x07,0xC0,0x1F,0xE0,0x00,0x00,0x1F,0xE0,0x00,0x00,0x0F,0xE0,\
	0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x00,0x00,0x0F,0xE0,0x0F,0xC0,0x0F,0xE0,\
	0x1F,0xE0,0x0F,0xE0,0x1F,0xE0,0x0F,0xE0,0x1F,0xE0,0x0F,0xE0,0x1F,0xE0,0x1F,0xE0,\
	0x1F,0xC0,0x1F,0xC0,0x1F,0xC0,0x1F,0xC0,0x1F,0xC0,0x3F,0x80,0x0F,0xE0,0x7F,0x80,\
	0x07,0xF9,0xFF,0x00,0x01,0xFF,0xFC,0x00,0x00,0x7F,0xF0,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	
};


uint8_t	Num_6[224] 	=
{
/*--  文字:  6  --*/
/*--  隶书42;  此字体下对应的点阵为：宽x高=28x56   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=32x56  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0,0x00,0x00,0x3C,0x7C,0x00,
0x00,0xF0,0x3E,0x00,0x01,0xE0,0x3F,0x00,0x03,0xC0,0x3F,0x00,0x07,0xC0,0x3F,0x00,
0x07,0x80,0x3E,0x00,0x0F,0x80,0x00,0x00,0x0F,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,
0x1F,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,
0x3F,0x0F,0xF0,0x00,0x3F,0x7F,0xFC,0x00,0x3F,0xF8,0x7E,0x00,0x3F,0xE0,0x3F,0x00,
0x3F,0xC0,0x1F,0x00,0x3F,0x80,0x0F,0x80,0x3F,0x80,0x0F,0x80,0x3F,0x00,0x0F,0xC0,
0x3F,0x00,0x07,0xC0,0x3F,0x00,0x07,0xC0,0x3F,0x00,0x07,0xC0,0x3F,0x00,0x07,0xC0,
0x3F,0x00,0x07,0xC0,0x1F,0x00,0x07,0xC0,0x1F,0x00,0x07,0xC0,0x1F,0x00,0x0F,0x80,
0x0F,0x80,0x0F,0x80,0x0F,0x80,0x0F,0x80,0x07,0xC0,0x0F,0x00,0x03,0xE0,0x1E,0x00,
0x01,0xF0,0x3C,0x00,0x00,0xF8,0x78,0x00,0x00,0x3F,0xE0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

};


uint8_t	Num_7[224] 	=
{
/*--  文字:  7  --*/
/*--  隶书42;  此字体下对应的点阵为：宽x高=28x56   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=32x56  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xC0,0x0F,0xFF,0xFF,0xC0,
0x0F,0xFF,0xFF,0x80,0x0F,0x80,0x07,0x00,0x1F,0x00,0x0F,0x00,0x1E,0x00,0x0E,0x00,
0x1C,0x00,0x1E,0x00,0x1C,0x00,0x3C,0x00,0x1C,0x00,0x3C,0x00,0x00,0x00,0x78,0x00,
0x00,0x00,0x70,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0xF0,0x00,0x00,0x01,0xE0,0x00,
0x00,0x01,0xE0,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0xC0,0x00,0x00,0x07,0xC0,0x00,
0x00,0x07,0x80,0x00,0x00,0x0F,0x80,0x00,0x00,0x0F,0x80,0x00,0x00,0x0F,0x00,0x00,
0x00,0x1F,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x3F,0x00,0x00,
0x00,0x3F,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x7F,0x00,0x00,
0x00,0x7F,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x7F,0x00,0x00,
0x00,0x7F,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00


};
uint8_t	Num_8[224] 	=
{
/*--  文字:  8  --*/
/*--  隶书42;  此字体下对应的点阵为：宽x高=28x56   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=32x56  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xE0,0x00,0x01,0xE0,0xF8,0x00,
0x07,0xC0,0x3C,0x00,0x0F,0x80,0x1E,0x00,0x0F,0x00,0x0F,0x00,0x1F,0x00,0x0F,0x00,
0x1E,0x00,0x0F,0x80,0x1E,0x00,0x0F,0x80,0x1E,0x00,0x0F,0x80,0x1E,0x00,0x0F,0x80,
0x1F,0x00,0x0F,0x80,0x1F,0x80,0x0F,0x80,0x1F,0xC0,0x0F,0x00,0x0F,0xE0,0x1E,0x00,
0x07,0xF0,0x3C,0x00,0x03,0xFC,0x78,0x00,0x01,0xFF,0xF0,0x00,0x00,0x7F,0xE0,0x00,
0x01,0xFF,0xF0,0x00,0x03,0xC7,0xF8,0x00,0x07,0x81,0xFE,0x00,0x0F,0x00,0xFE,0x00,
0x1F,0x00,0x3F,0x00,0x1E,0x00,0x1F,0x80,0x3E,0x00,0x1F,0x80,0x3E,0x00,0x0F,0x80,
0x3C,0x00,0x0F,0x80,0x3C,0x00,0x07,0x80,0x3C,0x00,0x07,0x80,0x3C,0x00,0x07,0x80,
0x3E,0x00,0x0F,0x80,0x1E,0x00,0x0F,0x80,0x1E,0x00,0x0F,0x00,0x0F,0x00,0x1E,0x00,
0x07,0x80,0x3C,0x00,0x01,0xE0,0xF8,0x00,0x00,0x7F,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00


};
/*--  文字:  9  --*/
/*--  隶书42;  宽度x高度=32x56  --*/
uint8_t	Num_9[224] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x7F,0xF0,0x00,0x01,0xFF,0xFC,0x00,0x07,0xF9,0xFE,0x00,\
	0x0F,0xF0,0x7F,0x00,0x0F,0xE0,0x3F,0x80,0x1F,0xC0,0x3F,0x80,0x1F,0xC0,0x1F,0xC0,\
	0x3F,0x80,0x1F,0xC0,0x3F,0x80,0x1F,0xE0,0x3F,0x80,0x0F,0xE0,0x3F,0x80,0x0F,0xE0,\
	0x3F,0x80,0x0F,0xE0,0x3F,0x80,0x0F,0xE0,0x3F,0x80,0x0F,0xE0,0x3F,0x80,0x0F,0xF0,\
	0x3F,0x80,0x1F,0xF0,0x3F,0xC0,0x1F,0xF0,0x3F,0xC0,0x3F,0xF0,0x1F,0xE0,0x7F,0xF0,\
	0x1F,0xF0,0xFF,0xF0,0x0F,0xFB,0xFF,0xE0,0x0F,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,\
	0x00,0xFF,0xDF,0xE0,0x00,0x00,0x1F,0xE0,0x00,0x00,0x1F,0xE0,0x00,0x00,0x1F,0xC0,\
	0x00,0x00,0x1F,0xC0,0x00,0x00,0x3F,0xC0,0x00,0x00,0x3F,0x80,0x0F,0xE0,0x3F,0x80,\
	0x0F,0xE0,0x7F,0x00,0x0F,0xF0,0x7F,0x00,0x0F,0xF0,0xFE,0x00,0x0F,0xF1,0xFC,0x00,\
	0x0F,0xF7,0xF8,0x00,0x07,0xFF,0xF0,0x00,0x01,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	
};



















//小号字体数字显示区域
/*--  文字:  0  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_00[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF0,0x1F,0x78,\
	0x1E,0x3C,0x3C,0x3C,0x3C,0x3E,0x7C,0x1E,0x7C,0x1E,0x78,0x1E,0x78,0x1F,0x78,0x1F,\
	0x78,0x1F,0x78,0x1E,0x7C,0x1E,0x7C,0x1E,0x3C,0x3E,0x3C,0x3C,0x1E,0x3C,0x1F,0x78,\
	0x07,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  1  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_01[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x03,0xC0,\
	0x1F,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,\
	0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x03,0xE0,\
	0x1F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  2  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_02[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF0,0x1E,0x7C,\
	0x3C,0x3C,0x3C,0x3E,0x7C,0x3E,0x7C,0x3E,0x3C,0x3E,0x00,0x3C,0x00,0x78,0x00,0xF8,\
	0x01,0xE0,0x03,0xC0,0x07,0x80,0x0F,0x00,0x1E,0x0E,0x3C,0x0E,0x78,0x1E,0x7F,0xFE,\
	0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  3  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_03[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0,0x3C,0xF8,\
	0x3C,0x7C,0x3C,0x3C,0x3C,0x3C,0x00,0x3C,0x00,0x7C,0x00,0xF0,0x07,0xE0,0x00,0xF8,\
	0x00,0x3C,0x00,0x3E,0x00,0x1E,0x00,0x1E,0x3C,0x1E,0x7C,0x3E,0x7C,0x3C,0x3C,0x78,\
	0x0F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  4  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_04[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0xF0,0x01,0xF0,\
	0x03,0xF0,0x03,0xF0,0x07,0xF0,0x0F,0xF0,0x0E,0xF0,0x1E,0xF0,0x1C,0xF0,0x38,0xF0,\
	0x78,0xF0,0x70,0xF0,0xFF,0xFE,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x01,0xF8,\
	0x07,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  5  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_05[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFE,0x3F,0xFE,\
	0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3F,0xF0,0x3E,0x7C,0x3C,0x3C,\
	0x1C,0x3E,0x00,0x1E,0x00,0x1E,0x3C,0x1E,0x7C,0x3E,0x7C,0x3E,0x3C,0x3C,0x3E,0x78,\
	0x0F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  6  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_06[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xF8,0x0F,0x7C,\
	0x1E,0x3C,0x3C,0x3C,0x3C,0x00,0x7C,0x00,0x7C,0x00,0x7F,0xF8,0x7F,0x7C,0x7E,0x3E,\
	0x7C,0x1E,0x78,0x1E,0x78,0x1E,0x7C,0x1E,0x7C,0x1E,0x3C,0x1E,0x3E,0x3C,0x1F,0x7C,\
	0x07,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  7  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_07[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFE,0x3F,0xFC,\
	0x7C,0x3C,0x78,0x38,0x70,0x70,0x00,0x70,0x00,0xE0,0x01,0xE0,0x01,0xE0,0x03,0xC0,\
	0x03,0xC0,0x03,0xC0,0x07,0xC0,0x07,0x80,0x07,0x80,0x07,0x80,0x0F,0x80,0x0F,0x80,\
	0x07,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  8  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_08[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0,0x3E,0x7C,\
	0x3C,0x3E,0x78,0x1E,0x78,0x1E,0x7C,0x1E,0x3E,0x3C,0x3F,0x3C,0x0F,0xF0,0x0F,0xF0,\
	0x3C,0xFC,0x78,0x7C,0x78,0x3E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x3E,0x7C,\
	0x0F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  9  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_09[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0,0x3E,0x78,\
	0x3C,0x3C,0x7C,0x3E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7C,0x3E,\
	0x3E,0xFE,0x1F,0xFE,0x00,0x3E,0x00,0x3E,0x00,0x3C,0x3C,0x7C,0x3E,0x78,0x3E,0xF0,\
	0x1F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  .  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_0dian[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x0F,0xC0,0x1F,0xE0,0x1F,0xE0,\
	0x1F,0xE0,0x0F,0xC0,0x07,0x80,0x00,0x00,0x00,0x00
};
/*--  文字:  H  --*/
/*--  隶书22;  现调整为：宽度x高度=16x29  --*/
uint8_t	Num_0H[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x7E,0x78,0x3C,\
	0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x7F,0xFC,\
	0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,\
	0xFC,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

/*--  文字:  z  --*/
/*--  隶书22; ，现调整为：宽度x高度=16x29  --*/
uint8_t	Num_0z[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xF8,0x38,0x70,0x30,0xF0,0x71,0xE0,\
	0x01,0xC0,0x03,0x80,0x07,0x80,0x07,0x00,0x0E,0x18,0x1E,0x18,0x3C,0x38,0x38,0x78,\
	0x7F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  K  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_0K[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFC,0x38,0x78,\
	0x38,0x70,0x38,0xE0,0x39,0xC0,0x39,0x80,0x3B,0x80,0x3F,0x00,0x3F,0x80,0x3F,0x80,\
	0x3B,0xC0,0x39,0xC0,0x39,0xE0,0x38,0xE0,0x38,0x70,0x38,0x70,0x38,0x38,0x38,0x3C,\
	0xFE,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

/*--  文字:  n  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_0n[58] 	=
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0xFB,0xF0,0x3E,0x78,0x3C,0x38,0x38,0x38,
0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
0xFE,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  m  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_0m[58] 	=
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFC,0x7B,0xDC,0x73,0x9C,0x73,0x9E,
0x73,0x9E,0x73,0x9E,0x73,0x9E,0x73,0x9E,0x73,0x9E,0x73,0x9E,0x73,0x9E,0x73,0x9E,
0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

/*--  文字:  C  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_0C[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFC,0x1F,0x3E,\
	0x3E,0x1E,0x3C,0x0E,0x7C,0x0E,0x78,0x00,0x78,0x00,0xF8,0x00,0xF8,0x00,0xF8,0x00,\
	0xF8,0x00,0xF8,0x00,0x78,0x00,0x78,0x0E,0x7C,0x0E,0x7C,0x1E,0x3C,0x1C,0x1F,0x78,\
	0x07,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*--  文字:  W  --*/
/*--  隶书22;  此字体下对应的点阵为：宽x高=16x29   --*/
uint8_t	Num_0W[58] 	=
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x7B,0xCE,\
	0x7B,0xCE,0x7B,0xDE,0x7B,0xFE,0x7B,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0xFC,0x3F,0xFC,\
	0x3F,0xFC,0x3F,0xF8,0x1F,0xF8,0x1F,0xF8,0x1F,0xF8,0x1F,0xF8,0x1E,0x78,0x1E,0x78,\
	0x0E,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
/*******************************************************************************
* Function Name  : LCD_CtrlLinesConfig
* Description    : Configures LCD Control lines (FSMC Pins) in alternate function
                   Push-Pull mode.
* Input          : None
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
static void LCD_CtrlLinesConfig(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	
	/* Enable FSMC, GPIOD, GPIOE, GPIOF, GPIOG and AFIO clocks */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_GPIOF | 
	                       RCC_APB2Periph_GPIOG | RCC_APB2Periph_AFIO, ENABLE);
	
	/* Set PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
	 PD.10(D15), PD.14(D0), PD.15(D1) as alternate function push pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 | 
	                            GPIO_Pin_15/*YU*/| GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
	
	/* Set PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
	 PE.14(D11), PE.15(D12) as alternate function push pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | 
	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | 
	                            GPIO_Pin_15;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
	
	/* Set PE.05(A21), PE.06(A22) as alternate function push pull 
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6;
	GPIO_Init(GPIOE, &GPIO_InitStructure);		 */
	
	/* Set PF.00(A0 (RS)) as alternate function push pull 
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
	GPIO_Init(GPIOF, &GPIO_InitStructure);	   */
	
	/* Set PG.12(NE4) as alternate function push pull - CE3(LCD /CS)
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_Init(GPIOG, &GPIO_InitStructure);		   */
}

/*******************************************************************************
* Function Name  : LCD_FSMCConfig
* Description    : Configures the Parallel interface (FSMC) for LCD(Parallel mode)
* Input          : None
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
static void LCD_FSMCConfig(void)
{
	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
	FSMC_NORSRAMTimingInitTypeDef FSMC_NORSRAMTimingInitStructure;
	/* FSMC读速度设置 */
	FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 5;  /* 地址建立时间  */
	FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;	   
	FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 5;	   /* 数据建立时间  */
	FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0x00;
	FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0x00;
	FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0x00;
	FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;	/* FSMC 访问模式 */
	
	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM4;
	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;
	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
	/* FSMC写速度设置 */
	FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 1;   /* 地址建立时间  */
	FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;	   
	FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 1;	   /* 数据建立时间  */
	FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0x00;
	FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0x00;
	FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0x00;
	FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;	/* FSMC 访问模式 */
	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;	  
	
	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
	
	/* Enable FSMC Bank4_SRAM Bank */
	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);  
}

/*******************************************************************************
* Function Name  : LCD_Configuration
* Description    : Configure the LCD Control pins and FSMC Parallel interface
* Input          : None
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
static void LCD_Configuration(void)
{
	/* Configure the LCD Control pins --------------------------------------------*/
	LCD_CtrlLinesConfig();
	
	/* Configure the FSMC Parallel interface -------------------------------------*/
	LCD_FSMCConfig();
}

/*******************************************************************************
* Function Name  : LCD_WriteReg
* Description    : controller command
* Input          : - cmd: writes command.
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
static __inline void LCD_WriteCommand(uint16_t cmd)
{
	/* Write cmd */
	LCD_REG = cmd;
}

/*******************************************************************************
* Function Name  : LCD_WriteRAM
* Description    : Writes to the LCD RAM.
* Input          : - data: the pixel color in RGB mode (5-6-5).
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
static __inline void LCD_WriteData(uint16_t data)					 
{
	/* Write 16-bit data */
	LCD_RAM = data;
}

/*******************************************************************************
* Function Name  : LCD_ReadRAM
* Description    : Reads the LCD RAM.
* Input          : None
* Output         : None
* Return         : LCD RAM Value.
* Attention		 : None
*******************************************************************************/
static __inline uint16_t LCD_ReadData(void)
{  
	/* Read 16-bit data */
	return LCD_RAM;
}

/*******************************************************************************
* Function Name  : SSD1963_SSD1963_GPIO_WR
* Description    : Set a GPIO pin to state high(1) or low(0)
* Input          : - pin: LCD_RESET or LCD_SPENA or LCD_SPCLK  or LCD_SPDAT
*                  - state: 0 for low and 1 for high
* Output         : None
* Return         : None
* Attention		 : Set the GPIO pin an output prior using this function
*******************************************************************************/
static void SSD1963_GPIO_WR(uint8_t pin, uint8_t state)
{
	static uint8_t _gpioStatus = 0;  /* ssd1963 specific 静态变量 */
	
	if( state )
	{
		_gpioStatus = _gpioStatus | pin;
	}
	else
	{
		_gpioStatus = _gpioStatus & ( ~pin );
	}
	
	LCD_WriteCommand(0xBA);		     /* Set GPIO value */
	LCD_WriteData(_gpioStatus);
}

/*******************************************************************************
* Function Name  : SSD1963_SPI_Write
* Description    : SPI Write
* Input          : - byte: data
* Output         : None
* Return         : None
* Attention		 : GPIO pins for the SPI port set all output prior to
*                  using this function
*******************************************************************************/
static void SSD1963_SPI_Write(uint8_t byte)
{
	uint8_t bit_ctr;
	
	for( bit_ctr = 0; bit_ctr < 8; bit_ctr++ )
	{
		if( byte & 0x80 )
		{
			SSD1963_GPIO_WR(LCD_SPDAT,1);
		}
		else
		{
			SSD1963_GPIO_WR(LCD_SPDAT,0);
		}
		SSD1963_GPIO_WR(LCD_SPCLK,0);
		SSD1963_GPIO_WR(LCD_SPCLK,1);
		byte = ( byte << 1 );
	}
}

/*******************************************************************************
* Function Name  : SSD1963_SPI_WriteReg
* Description    : write reg
* Input          : - reg: 
*                  - cmd: 
* Output         : None
* Return         : None
* Attention		 : GPIO pins for the SPI port set all output prior to
*                  using this function
*******************************************************************************/
static void SSD1963_SPI_WriteReg(uint8_t reg, uint16_t cmd)
{
	SSD1963_GPIO_WR(LCD_SPENA,0);
	cmd = ( (reg << 10) | (1 << 9) | cmd );
	SSD1963_SPI_Write( ( (uint8_t) (cmd)>>8) );
	SSD1963_SPI_Write( ( (uint8_t) cmd) );
	SSD1963_GPIO_WR(LCD_SPENA,1);
}

/*******************************************************************************
* Function Name  : delay_ms
* Description    : Delay Time
* Input          : - cnt: Delay Time
* Output         : None
* Return         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
static void delay_ms(uint16_t ms)    
{ 
	uint16_t i,j; 
	for( i = 0; i < ms; i++ )
	{ 
		for( j = 0; j < 1141; j++ );
	}
} 

/*******************************************************************************
* Function Name  : LCD_Initializtion
* Description    : SSD1963 Resets
* Input          : None
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void LCD_Initializtion(void)
{
	LCD_Configuration();

	LCD_SetBacklight(0x00);//优先进行亮度调节。。最暗状态

	/* Set MN(multipliers) of PLL, VCO = crystal freq * (N+1) */
	/* PLL freq = VCO/M with 250MHz < VCO < 800MHz */
	/* The max PLL freq is around 120MHz. To obtain 120MHz as the PLL freq */
	LCD_WriteCommand(0xE2);			    /* Set PLL with OSC = 10MHz (hardware) */
	/* Multiplier N = 35, VCO (>250MHz)= OSC*(N+1), VCO = 360MHz */
	LCD_WriteData(0x23);
	LCD_WriteData(0x02);				/* Divider M = 2, PLL = 360/(M+1) = 120MHz */
	LCD_WriteData(0x54);				/* Validate M and N values */	
	
	LCD_WriteCommand(0xE0);			    /* Start PLL command */
	LCD_WriteData(0x01);				/* enable PLL */	
	
	delay_ms(10);						/* wait stablize */
	LCD_WriteCommand(0xE0);			    /* Start PLL command again */
	LCD_WriteData(0x03);				/* now, use PLL output as system clock */		
	/* once PLL locked (at 120MHz), the data hold time set shortest */
	LCD_WriteCommand(0x01);			    /* Soft reset */
	delay_ms(10);
	
	/* Set LSHIFT freq, i.e. the DCLK with PLL freq 120MHz set previously */
	/* Typical DCLK for TYX350TFT320240 is 6.5MHz in 24 bit format */
	/* 6.5MHz = 120MHz*(LCDC_FPR+1)/2^20 */
	/* LCDC_FPR = 56796 (0x00DDDC) */
	LCD_WriteCommand(0xE6);
	LCD_WriteData(0x00);
	LCD_WriteData(0xDD);
	LCD_WriteData(0xDC);
	
	/* Set panel mode, varies from individual manufacturer */
	LCD_WriteCommand(0xB0);
	
	LCD_WriteData(0x20);				/* set 24-bit 3.5" TFT Panel */
	LCD_WriteData(0x00);				/* set Hsync+Vsync mode */
	LCD_WriteData((DISP_HOR_RESOLUTION-1)>>8&0x07); /* Set panel size */
	LCD_WriteData((DISP_HOR_RESOLUTION-1)&0xff);
	LCD_WriteData((DISP_VER_RESOLUTION-1)>>8&0x07);
	LCD_WriteData((DISP_VER_RESOLUTION-1)&0xff);
	LCD_WriteData(0x00);				/* RGB sequence */
	
	/* Set horizontal period */
	LCD_WriteCommand(0xB4);
	
	#define HT ( DISP_HOR_RESOLUTION + DISP_HOR_PULSE_WIDTH + DISP_HOR_BACK_PORCH + DISP_HOR_FRONT_PORCH )
	LCD_WriteData((HT-1)>>8);	
	LCD_WriteData(HT-1);
	
	#define HPS ( DISP_HOR_PULSE_WIDTH + DISP_HOR_BACK_PORCH )
	LCD_WriteData((HPS-1)>>8);
	LCD_WriteData(HPS-1);
	LCD_WriteData(DISP_HOR_PULSE_WIDTH-1);
	LCD_WriteData(0x00);
	LCD_WriteData(0x00);
	LCD_WriteData(0x00);
	
	/* Set vertical period */
	LCD_WriteCommand(0xB6);
	
	#define VT ( DISP_VER_PULSE_WIDTH + DISP_VER_BACK_PORCH + DISP_VER_FRONT_PORCH + DISP_VER_RESOLUTION )
	LCD_WriteData((VT-1)>>8);
	LCD_WriteData(VT-1);
	
	#define VSP ( DISP_VER_PULSE_WIDTH + DISP_VER_BACK_PORCH )
	LCD_WriteData((VSP-1)>>8);
	LCD_WriteData(VSP-1);
	LCD_WriteData(DISP_VER_PULSE_WIDTH-1);
	LCD_WriteData(0x00);
	LCD_WriteData(0x00);
	
	/* Set pixel data interface */
	LCD_WriteCommand(0xF0);
	
	#ifdef USE_16BIT_PMP
	LCD_WriteData(0x03);		/* 16-bit(565 format) data */
	#else
	LCD_WriteData(0x00);		/* 8-bit data for 16bpp */
	#endif
	
	LCD_WriteCommand(0xB8);	    /* Set all GPIOs to output, controlled by host */
	LCD_WriteData(0x0f);		/* Set GPIO0 as output */
	LCD_WriteData(0x01);		/* GPIO[3:0] used as normal GPIOs */
	
	/* LL Reset to LCD */
	SSD1963_GPIO_WR(LCD_SPENA, 1);
	SSD1963_GPIO_WR(LCD_SPCLK, 1);
	SSD1963_GPIO_WR(LCD_SPDAT,1);
	SSD1963_GPIO_WR(LCD_RESET,1);
	SSD1963_GPIO_WR(LCD_RESET,0);
	delay_ms(1);
	SSD1963_GPIO_WR(LCD_RESET,1);
	
	SSD1963_SPI_WriteReg(0x00,0x07);
	SSD1963_SPI_WriteReg(0x01,0x00);
	SSD1963_SPI_WriteReg(0x02,0x03);
	SSD1963_SPI_WriteReg(0x03,0xcc);
	SSD1963_SPI_WriteReg(0x04,0x46);
	SSD1963_SPI_WriteReg(0x05,0x0d);
	SSD1963_SPI_WriteReg(0x06,0x00);
	SSD1963_SPI_WriteReg(0x07,0x00);
	SSD1963_SPI_WriteReg(0x08,0x08);
	SSD1963_SPI_WriteReg(0x09,0x40);
	SSD1963_SPI_WriteReg(0x0a,0x88);
	SSD1963_SPI_WriteReg(0x0b,0x88);
	SSD1963_SPI_WriteReg(0x0c,0x30);
	SSD1963_SPI_WriteReg(0x0d,0x20);
	SSD1963_SPI_WriteReg(0x0e,0x6a);
	SSD1963_SPI_WriteReg(0x0f,0xa4);
	SSD1963_SPI_WriteReg(0x10,0x04);
	SSD1963_SPI_WriteReg(0x11,0x24);
	SSD1963_SPI_WriteReg(0x12,0x24);
	SSD1963_SPI_WriteReg(0x1e,0x00);
	SSD1963_SPI_WriteReg(0x20,0x00);				
	
	LCD_WriteCommand(0x29);	    /* Turn on display; show the image on display */	
	
	LCD_SetBacklight(0x00);	
//	LCD_SetBacklight(0xff);	
}

/******************************************************************************
* Function Name  : LCD_SetArea
* Description    : Sets Area.
* Input          : - start_x: start column
*                  - start_y: start row 
*				   - end_x: end column 
*				   - end_y: end row
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
static __inline void LCD_SetArea(uint16_t start_x, uint16_t start_y, uint16_t end_x, uint16_t end_y)
{
	LCD_WriteCommand(CMD_SET_COLUMN);
	LCD_WriteData(start_x>>8);
	LCD_WriteData(start_x);
	LCD_WriteData(end_x>>8);
	LCD_WriteData(end_x);
	
	LCD_WriteCommand(CMD_SET_PAGE);
	LCD_WriteData(start_y>>8);
	LCD_WriteData(start_y);
	LCD_WriteData(end_y>>8);
	LCD_WriteData(end_y);
}

/*******************************************************************************
* Function Name  : LCD_SetBacklight
* Description    : This function makes use of PWM feature of ssd1963 to adjust
*				   the backlight intensity.
* Input          : - intensity: intensity from
*                               0x00 (total backlight shutdown, PWM pin pull-down to VSS)
                                0xff (99% pull-up, 255/256 pull-up to VDD)
* Output         : None
* Return         : None
* Attention		 : The base frequency of PWM set to around 300Hz with PLL set to 120MHz.
*                  This parameter is hardware dependent.
*                  Backlight circuit with shutdown pin connected to PWM output of ssd1963.
*******************************************************************************/
void LCD_SetBacklight(uint8_t intensity)
{
	LCD_WriteCommand(0xBE);		    /* Set PWM configuration for backlight control */
	LCD_WriteData(0x0E);			/* PWMF[7:0] = 14, PWM base freq = PLL/(256*(1+14))/256 = */ 
								    /* 122Hz for a PLL freq = 120MHz */
	LCD_WriteData(intensity);		/* Set duty cycle, from 0x00 (total pull-down) to 0xFF */ 
								    /* (99% pull-up , 255/256) */
	LCD_WriteData(0x01);			/* PWM enabled and controlled by host (mcu) */
	LCD_WriteData(0x00);
	LCD_WriteData(0x00);
	LCD_WriteData(0x00);
}

/*******************************************************************************
* Function Name  : LCD_Clear
* Description    : 将屏幕填充成指定的颜色，如清屏，则填充 0xffff
* Input          : - Color: Screen Color
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void LCD_Clear(uint16_t Color)
{
	uint32_t index;
	
	LCD_SetArea(0,0,DISP_HOR_RESOLUTION -1 ,DISP_VER_RESOLUTION -1 );
	LCD_WriteCommand(CMD_WR_MEMSTART);
	for( index=0; index < DISP_HOR_RESOLUTION * DISP_VER_RESOLUTION; index++ )
	{
		LCD_WriteData(Color);
	}		 
}

/******************************************************************************
* Function Name  : LCD_GetPoint
* Description    : 获取指定座标的颜色值
* Input          : - Xpos: Row Coordinate
*                  - Xpos: Line Coordinate 
* Output         : None
* Return         : Screen Color
* Attention		 : None
*******************************************************************************/
uint16_t LCD_GetPoint(uint16_t Xpos,uint16_t Ypos)
{
	LCD_SetArea(Xpos,Ypos,Xpos,Ypos);
	LCD_WriteCommand(CMD_RD_MEMSTART);
	return LCD_ReadData();
}

/******************************************************************************
* Function Name  : LCD_SetPoint
* Description    : 在指定座标画点
* Input          : - Xpos: Row Coordinate
*                  - Ypos: Line Coordinate 
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void LCD_SetPoint(uint16_t Xpos,uint16_t Ypos,uint16_t point)	 //point为颜色值？？
{
	if( Xpos > DISP_HOR_RESOLUTION || Ypos > DISP_VER_RESOLUTION ) 
	{
		return;
	}
	LCD_SetArea(Xpos,Ypos,Xpos,Ypos);
	LCD_WriteCommand(CMD_WR_MEMSTART);
	LCD_WriteData(point);
}

/******************************************************************************
* Function Name  : LCD_DrawLine
* Description    : Bresenham's line algorithm
* Input          : - x1: A点行座标
*                  - y1: A点列座标 
*				   - x2: B点行座标
*				   - y2: B点列座标 
*				   - color: 线颜色
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/	 
void LCD_DrawLine( uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1 , uint16_t color )
{
    short dx,dy;      /* 定义X Y轴上增加的变量值 */
    short temp;       /* 起点 终点大小比较 交换数据时的中间变量 */

    if( x0 > x1 )     /* X轴上起点大于终点 交换数据 */
    {
	    temp = x1;
		x1 = x0;
		x0 = temp;   
    }
    if( y0 > y1 )     /* Y轴上起点大于终点 交换数据 */
    {
		temp = y1;
		y1 = y0;
		y0 = temp;   
    }
  
	dx = x1-x0;       /* X轴方向上的增量 */
	dy = y1-y0;       /* Y轴方向上的增量 */

    if( dx == 0 )     /* X轴上没有增量 画垂直线 */ 
    {
        do
        { 
            LCD_SetPoint(x0, y0, color);   /* 逐点显示 描垂直线 */
            y0++;
        }
        while( y1 >= y0 ); 
		return; 
    }
    if( dy == 0 )     /* Y轴上没有增量 画水平直线 */ 
    {
        do
        {
            LCD_SetPoint(x0, y0, color);   /* 逐点显示 描水平线 */
            x0++;
        }
        while( x1 >= x0 ); 
		return;
    }
	/* 布兰森汉姆(Bresenham)算法画线 */
    if( dx > dy )                         /* 靠近X轴 */
    {
	    temp = 2 * dy - dx;               /* 计算下个点的位置 */         
        while( x0 != x1 )
        {
	        LCD_SetPoint(x0,y0,color);    /* 画起点 */ 
	        x0++;                         /* X轴上加1 */
	        if( temp > 0 )                /* 判断下下个点的位置 */
	        {
	            y0++;                     /* 为右上相邻点，即（x0+1,y0+1） */ 
	            temp += 2 * dy - 2 * dx; 
	 	    }
            else         
            {
			    temp += 2 * dy;           /* 判断下下个点的位置 */  
			}       
        }
        LCD_SetPoint(x0,y0,color);
    }  
    else
    {
	    temp = 2 * dx - dy;                      /* 靠近Y轴 */       
        while( y0 != y1 )
        {
	 	    LCD_SetPoint(x0,y0,color);     
            y0++;                 
            if( temp > 0 )           
            {
                x0++;               
                temp+=2*dy-2*dx; 
            }
            else
			{
                temp += 2 * dy;
			}
        } 
        LCD_SetPoint(x0,y0,color);
	}
} 
/******************************************************************************
* Function Name  : LCD_Rectangle	  BY Yu Jingxiong  2011.11.13
* Description    : Draw A Rectangle 
* Input          : - x1: 矩形左上角X坐标
*                  - y1: 矩形左上角y坐标
*				   - x2: 矩形右下角X坐标
*				   - y2: 矩形右下角y坐标 
*				   - line_color: 线颜色
				   - fill_color: 填充颜色
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void LCD_Rectangle( uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1 , uint16_t line_color, uint16_t fill_color )
{
    uint32_t index;
		
   if( x0 > DISP_HOR_RESOLUTION || y0 > DISP_VER_RESOLUTION || x1 > DISP_HOR_RESOLUTION || y1 > DISP_VER_RESOLUTION ) 
	{
		return;
	} 
 
   LCD_DrawLine(x0, y0, x1, y0, line_color);
   LCD_DrawLine(x0, y0, x0, y1, line_color);
   LCD_DrawLine(x1, y1, x1, y0, line_color);
   LCD_DrawLine(x1, y1, x0, y1, line_color);
	
   LCD_SetArea(x0-1,y0-1,x1-1,y1-1);
   LCD_WriteCommand(CMD_WR_MEMSTART);
   for( index=0; index < DISP_HOR_RESOLUTION * DISP_VER_RESOLUTION; index++ )
	{
		LCD_WriteData(fill_color);
	}

}


/******************************************************************************
* Function Name  : PutChar
* Description    : 将Lcd屏上任意位置显示一个字符
* Input          : - Xpos: 水平坐标 
*                  - Ypos: 垂直坐标  
*				   - ASCI: 显示的字符
*				   - charColor: 字符颜色   
*				   - bkColor: 背景颜色 
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void PutChar( uint16_t Xpos, uint16_t Ypos, uint8_t ASCI, uint16_t charColor, uint16_t bkColor )
{
// 	uint16_t i, j;
//     uint8_t buffer[16], tmp_char;
//     GetASCIICode(buffer,ASCI);  /* 取字模数据 */
//     for( i=0; i<16; i++ )
//     {
//         tmp_char = buffer[i];
//         for( j=0; j<8; j++ )
//         {
//             if( (tmp_char >> 7 - j) & 0x01 == 0x01 )
//             {
//                 LCD_SetPoint( Xpos + j, Ypos + i, charColor );  /* 字符颜色 */
//             }
//             else
//             {
//                 LCD_SetPoint( Xpos + j, Ypos + i, bkColor );  /* 背景颜色 */
//             }
//         }
//     }
}

/******************************************************************************
* Function Name  : GUI_Text
* Description    : 在指定座标显示字符串
* Input          : - Xpos: 行座标
*                  - Ypos: 列座标 
*				   - str: 字符串
*				   - charColor: 字符颜色   
*				   - bkColor: 背景颜色 
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void GUI_Text(uint16_t Xpos, uint16_t Ypos, uint8_t *str,uint16_t Color, uint16_t bkColor)
{
    uint8_t TempChar;	//GUI_Text(44,10,"Touch crosshair to calibrate",0xffff,Black);
    do					//示例用法
    {
        TempChar = *str++;  
        PutChar( Xpos, Ypos, TempChar, Color, bkColor );    
        if( Xpos < DISP_HOR_RESOLUTION - 8 )
        {
            Xpos += 8;
        } 
        else if ( Ypos < DISP_VER_RESOLUTION - 16 )
        {
            Xpos = 0;
            Ypos += 16;
        }   
        else
        {
            Xpos = 0;
            Ypos = 0;
        }    
    }
    while ( *str != 0 );
}

/******************************************************************************
* Function Name  : PutChinese
* Description    : 将Lcd屏上任意位置显示一个中文字
* Input          : - Xpos: 水平坐标 
*                  - Ypos: 垂直坐标  
*				   - str: 显示的中文字
*				   - Color: 字符颜色   
*				   - bkColor: 背景颜色 
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void PutChinese(uint16_t Xpos,uint16_t Ypos,uint8_t *str,uint16_t Color,uint16_t bkColor)
{
// 	uint8_t i,j;
// 	uint8_t buffer[32];
// 	uint16_t tmp_char=0;
// 	
// 	GetGBKCode(buffer,str);  /* 取字模数据 */

// 	for ( i = 0; i < 16; i++ )
// 	{
// 		tmp_char = buffer[i*2];
// 		tmp_char = ( tmp_char << 8 );
// 		tmp_char |= buffer[2*i+1];
// 		for (j = 0; j < 16; j++ )
// 		{
// 		    if ( (tmp_char >> 15-j ) & 0x01 == 0x01 )
// 	        {
// 		        LCD_SetPoint(Xpos+j,Ypos+i,Color);  /* 字符颜色 */
// 	        }
// 	        else
// 	        {
// 	            LCD_SetPoint(Xpos+j,Ypos+i,bkColor);  /* 背景颜色 */
// 	        }
// 	    }
// 	}
}

/******************************************************************************
* Function Name  : GUI_Chinese
* Description    : 在指定座标显示字符串
* Input          : - Xpos: 行座标
*                  - Ypos: 列座标 
*				   - str: 字符串
*				   - charColor: 字符颜色   
*				   - bkColor: 背景颜色 
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void GUI_Chinese(uint16_t Xpos, uint16_t Ypos, uint8_t *str,uint16_t Color, uint16_t bkColor)
{
	do
	{
		PutChinese(Xpos,Ypos,str++,Color,bkColor);
		str++;
		if ( Xpos < DISP_HOR_RESOLUTION - 16 )
		{
			Xpos += 16;
		}
		else if ( Ypos < DISP_VER_RESOLUTION - 16 )
		{
			Xpos = 0;
			Ypos += 16;
		}
        else
        {
            Xpos = 0;
            Ypos = 0;
        }       
    }
    while(*str!=0);
}  


/******************************************************************************
* Function Name  : LCD_Rectangle_Outside	  BY Yu Jingxiong  2011.12.12
* Description    : Draw A Rectangle 
* Input          : - x0: 矩形左上角X坐标   注意保证输入的右下角值大于左上角值
*                  - y0: 矩形左上角y坐标
*				   - x1: 矩形右下角X坐标
*				   - y1: 矩形右下角y坐标 
*				   - line_color: 线颜色
//仅仅显示一个矩形框。。不填充
*******************************************************************************/
void LCD_Rectangle_Outside( uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1 , uint16_t line_color )
{		
   LCD_DrawLine(x0, y0, x1, y0, line_color);
   LCD_DrawLine(x0, y0, x0, y1, line_color);
   LCD_DrawLine(x1, y1, x1, y0, line_color);
   LCD_DrawLine(x1, y1, x0, y1, line_color);
}
/*******************************************************************************/
//进行16位真彩色图片显示。。pic为图片地址，采用Byte 保存
//显示满屏图片320*240 == 76800
// Picture_Pixel_Number  图片像素点总数,注意次函数中像素点总数等于取模软件点数一半，此处应限于65536之内	，本次最大到4074
//yujingxiong  2011.12.07晚上
//默认	终点xy的值均大于起点xy的值
//保证 EndX - StartX == X像素数目-1 ；	 EndY - StartY == Y像素数目-1 ；
/********************************************************************************/
void LCD_DrawPicture(uint16_t StartX,uint16_t StartY,uint16_t EndX,uint16_t EndY,  uint8_t *pic , uint16_t Picture_Pixel_Number)
{
   	uint16_t i;
	uint16_t x,y;
	uint16_t Pixel_Color[5000] = {0};	 //本次应用之中最大为4074个点数。。当显示大于5000个像素点时候需更改

   for( i=0; i<Picture_Pixel_Number; i++ )
	{
	   Pixel_Color[i] = (pic[2*i])*256+	pic[2*i+1];	   	   	   
	}
   for( y=StartY; y<EndY ; y++ )  //起点为（StartX，StartY）终点为（EndX-1，EndY-1）
    for( x=StartX; x<EndX ; x++ )   //逐行显示，显示EndY - StartY 行，与图像点分布有关系   
	 {
	    LCD_SetPoint(x,y,Pixel_Color[(y-StartY)*(EndX-StartX+1)+(x-StartX)]);
	 }
}
/*********************************************************************
* Function Name  : LCD_FLSAH_DrawPicture
* Description    : 读取FLASH中的图片数据进行显示操纵
* Input          : - StartX: X起点
*                  - StartY: Y起点 
*				   - EndX: X终点
*				   - EndY: Y终点   
*				   - pic: 数据组指针强制转换结果
* By yujingxiong    2012.04.26 
example  ：LCD_FLSAH_DrawPicture( 0, 0, 31, 59, (uint8_t *)&Glink32_60 );
const unsigned char Glink32_60[3840]
*********************************************************************/
void LCD_FLSAH_DrawPicture(uint16_t StartX,uint16_t StartY,uint16_t EndX,uint16_t EndY, uint8_t * pic)
{
   	uint16_t i;
	uint16_t x,y;
	uint16_t Once_Number;		//每次从FLASH中转移的像素点最大个数，不大于640
	uint8_t Half_Pixel_Color[640] = {0};
	uint16_t Once_Pixel_Color[320] = {0};  //此处以液晶屏整行最大值为参考基准

	Once_Number = (EndX - StartX + 1);	  //一次从FLASH中读取数目

   for( y=StartY; y<=EndY ; y++ )  //一次取一行点，转换，绘制一行点  
	{
	   memcpy(Half_Pixel_Color, ( pic + 2*Once_Number*(y-StartY)) , 2*Once_Number);	 //由FLASH中转移至RAM中
	     for( i=0; i < Once_Number; i++ )
		  {
		     Once_Pixel_Color[i] = (Half_Pixel_Color[2*i])*256 + Half_Pixel_Color[2*i+1];	   	   	   
		  }
	   for( x=StartX; x<=EndX ; x++ )   //逐行显示，显示EndY - StartY 行，与图像点分布有关系 
	     LCD_SetPoint(x,y,Once_Pixel_Color[x - StartX]);
	}
}
																			
/*********************************************************************************************************
      END FILE
*********************************************************************************************************/


/******************************************************************************
* Function Name  : LCD_Batter_Show	  BY Yu Jingxiong  2011.11.15		  ok
* Description    : Draw A battery on LCD 
* Input          : - x0: 电池左上角X坐标   注意保证输入的右下角值大于左上角值
*                  - y0: 电池左上角y坐标
- rank ：电池等级状态 0红 1黄 2绿 3绿  4充电状态
*******************************************************************************/
#define LEVEL_POWER    0  //外部供电
#define LEVEL_FULL     2  //充满电
#define LEVEL_CHARGE   4  //正在充电
#define LEVEL_4        6  //电池4格
#define LEVEL_3        7  //电池3格
#define LEVEL_2        8  //电池2格
#define LEVEL_1        9  //电池1格
#define LEVEL_0        10  //电池0格
#define LEVEL_SHUTDOWN 11 //电池自动关机
void LCD_Batter_Show( uint16_t x0, uint16_t y0 ,uint16_t rank )			
{
	uint16_t x1 = x0+33;
	uint16_t y1 = y0+17;

// 	if( x0 > DISP_HOR_RESOLUTION || y0 > DISP_VER_RESOLUTION || x1 > DISP_HOR_RESOLUTION || y1 > DISP_VER_RESOLUTION  ) 
// 	{
// 		return;
// 	} 
#ifdef _DEBUG_
	switch(rank)
	{					//White   Black   Grey   Blue  Blue2    Red    Magenta   Cyan   Yellow 
	case LEVEL_0: 
		gl_text(250,15,"better 0",-1);
		break;
	case LEVEL_1: 
		gl_text(250,15,"better 1",-1);
		break;
	case LEVEL_2: 
		gl_text(250,15,"better 2",-1);
		break;
	case LEVEL_3: 
		gl_text(250,15,"better 3",-1);
		break;
	case LEVEL_4: 
		gl_text(250,15,"better 4",-1);
		break;
	case LEVEL_CHARGE: 
		gl_text(250,15,"charge...",-1);
		break;
	case LEVEL_FULL: 
		gl_text(250,15,"full",-1);
		break;
	case LEVEL_POWER: 
		gl_text(250,15,"outside",-1);
		break;
	default: 
		break;
	
	}
#else
	switch(rank)
	{					//White   Black   Grey   Blue  Blue2    Red    Magenta   Cyan   Yellow 
	case LEVEL_0: 
		//LCD_Rectangle(  x0+1,  y0+1,  x0+8,  y0+16 ,  Red,  Red );
		LCD_FLSAH_DrawPicture(250,15,250+56-1,15+44-1,(uint8_t*)gImage_battery_0_4);
		break ; 	
	case LEVEL_1: 
		//LCD_Rectangle(  x0+1,  y0+1,  x0+16,  y0+16 ,  Yellow,  Yellow );
		LCD_FLSAH_DrawPicture(250,15,250+56-1,15+44-1,(uint8_t*)gImage_battery_1_4);
		break ; 
	case LEVEL_2: 
		//LCD_Rectangle(  x0+1,  y0+1,  x0+24,  y0+16 ,  Green,  Green );
		LCD_FLSAH_DrawPicture(250,15,250+56-1,15+44-1,(uint8_t*)gImage_battery_2_4);
		break ; 
	case LEVEL_3: 
		//LCD_Rectangle(  x0+1,  y0+1,  x0+24,  y0+16 ,  Green,  Green );
		LCD_FLSAH_DrawPicture(250,15,250+56-1,15+44-1,(uint8_t*)gImage_battery_3_4);
		break ; 
	case LEVEL_4: 
	case LEVEL_FULL: 
	case LEVEL_POWER: 
		//LCD_Rectangle(  x0+1,  y0+1,  x0+24,  y0+16 ,  Green,  Green );
		LCD_FLSAH_DrawPicture(250,15,250+56-1,15+44-1,(uint8_t*)gImage_battery_4_4);
		break ; 
	case LEVEL_CHARGE: 
		//LCD_Rectangle(  x0+1,  y0+1,  x0+32,  y0+16 ,  Green,  Green );
		LCD_FLSAH_DrawPicture(250,15,250+56-1,15+44-1,(uint8_t*)gImage_battery_ac);
		break ;

	default :			    
		break ;
	} 
#endif
}

/******************************************************************************
* Function Name  : LCD_OperatMode_Selection	  BY Yu Jingxiong  2011.11.20	  ok
* Description    : Draw OperatMode Selection on LCD 
* Input          : - x0: 显示条左上角X坐标   注意保证输入的右下角值大于左上角值
*                  - y0: 显示条左上角y坐标
- mode ：波长选择，0 = CW、 1 = 270Hz、2 = 1KHz、3 = 2KHz  连续光/脉冲光选择
*******************************************************************************/
void LCD_OperatMode_Selection( uint16_t x0, uint16_t y0 ,uint16_t mode ,uint16_t Color, uint16_t BkColor )
{ 
	uint16_t x,y;
	//小号字体显示 16* 29
	switch(mode)
	{					//White   Black   BkColor   Blue  Color    Red    Magenta   Cyan   Yellow 
	case 0: 
		for( x=x0; x < x0+47; x++ )	//右侧触摸按键条宽
			for( y=y0; y < y0+29; y++ )
				LCD_SetPoint(x,y,BkColor);
		Show_Matrix_zimo(x0+47, y0, Num_0C,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+63, y0, Num_0W,  2, 29, Color , BkColor);
		for( x=x0+79; x < x0+111; x++ )	//右侧触摸按键条宽
			for( y=y0; y < y0+29; y++ )
				LCD_SetPoint(x,y,BkColor);
		break ; 	
	case 1: 
		Show_Matrix_zimo(x0, y0, Num_00,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+15, y0, Num_0dian,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+31, y0, Num_02,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+47, y0, Num_07,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+63, y0, Num_0K,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+79, y0, Num_0H,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+95, y0, Num_0z,  2, 29, Color , BkColor);
		break ; 
	case 2: 
		for( x=x0; x < x0+47; x++ )	
			for( y=y0; y < y0+29; y++ )
				LCD_SetPoint(x,y,BkColor);
		Show_Matrix_zimo(x0+47, y0, Num_01,  2, 29, Color , BkColor);	//确保KHz位置不变
		break ; 
	case 3: 
		Show_Matrix_zimo(x0+47, y0, Num_02,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+63, y0, Num_0K,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+79, y0, Num_0H,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+95, y0, Num_0z,  2, 29, Color , BkColor);
		break ;

	default :			    
		break ;			                          
	} 
}


/******************************************************************************
* Function Name  : LCD_Power_Control_Selection	  BY Yu Jingxiong  2011.11.21	  ok
* Description    : Draw Power Control on LCD 
* Input          : - x0: 显示条左上角X坐标   注意保证输入的右下角值大于左上角值
*                  - y0: 显示条左上角y坐标
*                  - Current_Power: 显示功率值

change ：波长选择，0 = decrease、 1 = 	increase  
操作方式：以 1dbm 递增或递减，变化范围是：-30dbm到3dbm，共34个等级
*******************************************************************************/
void LCD_Power_Control_Selection( uint16_t x0, uint16_t y0 ,int16_t Current_Power ,uint16_t CharColor, uint16_t BkColor )
{ 
}
void LCD_Power_Control_Selection_Ex( uint16_t x0, uint16_t y0 ,int16_t Current_Power ,uint16_t CharColor, uint16_t BkColor )
{ 
	uint16_t x,y;
	//uint8_t (*code[])[224] = {&Num_0,&Num_1,&Num_2,&Num_3,&Num_4,&Num_5,&Num_6,&Num_7,&Num_8,&Num_9};
	uint8_t *code[] = {(uint8_t*)Num_0,(uint8_t*)Num_1,(uint8_t*)Num_2,(uint8_t*)Num_3,(uint8_t*)Num_4,
						(uint8_t*)Num_5,(uint8_t*)Num_6,(uint8_t*)Num_7,(uint8_t*)Num_8,(uint8_t*)Num_9};
	int16_t tdisplay = Current_Power;
	uint8_t digit;
	if(tdisplay < 0) {
		Show_Matrix_zimo(x0, y0, Num_fuhao,  4,56, CharColor , BkColor);
		tdisplay = -tdisplay;
	}
	tdisplay %= 100;
	digit = tdisplay / 10;
	Show_Matrix_zimo(x0+32, y0, code[digit],  4,56, CharColor , BkColor);
	digit = tdisplay % 10;
	Show_Matrix_zimo(x0+62, y0, code[digit],  4,56, CharColor , BkColor);

	LCD_FLSAH_DrawPicture(x0+98,y0+13,x0+98+63-1,y0+13+33-1,(uint8_t*)gImage_dbm);	
	//Show_Matrix_zimo(x0+98, y0, Num_big_d,  4,56, CharColor , BkColor);
 	//Show_Matrix_zimo(x0+130, y0, Num_big_b,  4,56, CharColor , BkColor);
 	//Show_Matrix_zimo(x0+162, y0, Num_big_m,  4,56, CharColor , BkColor);
}
void LCD_RedLight_Show( uint16_t x0, uint16_t y0 ,uint8_t flag)
{
#ifdef _DEBUG_
	if(flag == 0)
		gl_text(0,0,"Red Off",20);
	else 
		gl_text(0,0,"Red On ",20);
#else
	if(flag == 0)
		LCD_FLSAH_DrawPicture(9,15,9+62-1,15+44-1,(uint8_t*)gImage_redlight_off);
	else 
		LCD_FLSAH_DrawPicture(9,15,9+62-1,15+44-1,(uint8_t*)gImage_redlight_on);
#endif
	
}



/******************************************************************************
* Function Name  : LCD_Timing_Display	  BY Yu Jingxiong  2011.11.15	  ok
* Description    : Draw Wavelength Selection on LCD 
* Input          : - x0: 显示条左上角X坐标   注意保证输入的右下角值大于左上角值
*                  - y0: 显示条左上角y坐标
- on_off ：定时器状态，0 倒计时关闭状态 OFF,  5min  ，10min  ，15min  ，30min  ，60min
*******************************************************************************/
void LCD_Timing_Display( uint16_t x0, uint16_t y0 ,uint16_t on_off )
{

	if( x0 > DISP_HOR_RESOLUTION || y0 > DISP_VER_RESOLUTION  ) 
	{
		return;
	} 
#ifdef _DEBUG_
	switch(on_off)
	{
	case 0:
		gl_text(125,15,"tim off  ",-1);
		break;
	case 1:
		break;
	case 2:
		gl_text(125,15,"tim 10min",-1);
		break;
	case 3:
		break;
	case 4:
		break;
	case 5:
		break;
	default:
		break;
	}
#else
	switch(on_off)
	{					//White   Black   Grey   Blue  Blue2    Red    Magenta   Cyan   Yellow 
	case 0:   //OFF
		LCD_FLSAH_DrawPicture(125,15,125+77-1,15+44-1,(uint8_t*)gImage_t_off);
		break ; 	
	case 1: 
		GUI_Text( x0,  y0,  "T-5Min ", Green,  Black);
		break ;
	case 2:
		LCD_FLSAH_DrawPicture(125,15,125+77-1,15+44-1,(uint8_t*)gImage_t_10min);
		break ; 
	case 3:
		//LCD_DrawPicture( x0-21, y0, x0+8, y0+35, Nao_Zhong_30_36_GREEN ,  1080);    
		GUI_Text( x0,  y0,  "T-15Min", Green,  Black);
		break ;
	case 4: 
		//LCD_DrawPicture( x0-21, y0, x0+8, y0+35, Nao_Zhong_30_36_GREEN ,  1080);   
		GUI_Text( x0,  y0,  "T-30Min", Green,  Black);
		break ;
	case 5: 
		//LCD_DrawPicture( x0-21, y0, x0+8, y0+35, Nao_Zhong_30_36_GREEN ,  1080);   
		GUI_Text( x0,  y0,  "T-60Min", Green,  Black);
		break ;

	default :			    
		break ;			                          
	} 
#endif
}

void LCD_Wavelength_Selection_Ex( uint16_t x0, uint16_t y0 ,uint16_t wave ,uint16_t Color, uint16_t BkColor )
{
	uint16_t x,y;
	switch(wave)
	{					//White   Black   BkColor   Color  Color2    Red    Magenta   Cyan   Yellow 
	case 0: 
		LCD_RunStop_Select( 130, 5, 1 );	   //x 130 y 5
		break ;
	case 1: 
		Show_Matrix_zimo(x0, y0, Num_01,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+16, y0, Num_03,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+32, y0, Num_01,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+48, y0, Num_00,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+64, y0, Num_0n,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+80, y0, Num_0m,  2, 29, Color , BkColor);
		break ;
	case 2: 
		Show_Matrix_zimo(x0, y0, Num_01,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+16, y0, Num_04,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+32, y0, Num_09,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+95, y0, Num_00,  4, 56, Color , BkColor);
		Show_Matrix_zimo(x0+64, y0, Num_0n,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+80, y0, Num_0m,  2, 29, Color , BkColor);
		break ; 
	case 3: 
		Show_Matrix_zimo(x0, y0, Num_01,  	 2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+16, y0, Num_05,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+32, y0, Num_05,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+48, y0, Num_00,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+64, y0, Num_0n,  2, 29, Color , BkColor);
		Show_Matrix_zimo(x0+80, y0, Num_0m,  2, 29, Color , BkColor);
		break ; 
	default :			    
		break ;			                          
	} 		

}

/******************************************************************************
* Function Name  : LCD_Menu_Select	  BY Yu Jingxiong  2011.11.24	  ok
* Description    : Draw menu selection on LCD 
* Input          : - x0: 显示条左上角X坐标   注意保证输入的右下角值大于左上角值
*                  - y0: 显示条左上角y坐标 
*******************************************************************************/
void LCD_RunStop_Select(uint16_t x0,uint16_t y0,uint16_t RunStop )	   //x 140 y 36
{ 
}

/***************************************************************************************************/
/******************************************************************************
* Function Name  : Show_Matrix_zimo
* Description    : 在指定座标显示字模提取软件提取的字模数据		  OK
* Input          : - Xpos: 起始行座标
*                  - Ypos: 起始列座标 
*				   - Buffer: 保存字模数据的数组地址。。。
*				   - Wide_char,  字模宽度，以字节计算，像素宽度 = Wide_char * 8
*				   - High     ， 字模高度，以像素点计算
*				   - charColor: 字符颜色   
*				   - bkColor: 背景颜色 
*******************************************************************************/
void Show_Matrix_zimo(uint16_t Xpos, uint16_t Ypos, uint8_t *Buffer, uint16_t Wide_char, uint16_t High, uint16_t charColor, uint16_t bkColor)
{
	uint16_t  x_char ,x;
	uint16_t  Temp_y;  //临时 Y坐标
	uint8_t  /* Temp_Buffer[1000], */tmp_char;	  //注意：最大显示字体的字节数目为1000

	//memcpy( Temp_Buffer, Buffer, Wide_char*High);

	for( Temp_y = Ypos; Temp_y< Ypos+High-1 ; Temp_y++)		//y坐标递增
	{
		for( x_char=0; x_char<Wide_char; x_char++ )	 //x坐标字符计数增量
		{
			tmp_char = Buffer[x_char + (Temp_y - Ypos)*Wide_char];
			for( x=0; x<8; x++ )
			{
				if( (tmp_char >> 7 - x) & 0x01 == 0x01 )
				{
					LCD_SetPoint( ( Xpos + x_char * 8 + x ), Temp_y, charColor );  /* 字符颜色 */
				}
				else
				{
					LCD_SetPoint( ( Xpos + x_char * 8 + x ), Temp_y, bkColor );  /* 背景颜色 */
				}
			}
		}
	}
}